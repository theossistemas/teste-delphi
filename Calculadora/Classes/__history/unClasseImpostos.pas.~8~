unit unClasseImpostos;

interface

uses
  System.SysUtils;

type

  TCalculo = class
  public
    function CalculaImposto(nValor: Double): Double; virtual; abstract;
  end;

  TImposto = class(TCalculo);


  TImpostoA = class(TImposto)
  public
    function CalculaImposto(nValor: Double): Double; override;
  end;

  TImpostoB = class(TImposto)
  public
    function CalculaImposto(nValor: Double): Double; override;
  end;

  TImpostoC = class(TImposto)
  public
    function CalculaImposto(nValor: Double): Double; override;
  end;


implementation

{ TImpostoA }

function TImpostoA.CalculaImposto(nValor: Double): Double;
var
  nResultado: Double;
begin
  nResultado := 0;
  try
    if (nValor <= 0) then
      Exit;

    nResultado := (nValor * 20 / 100) - 500;

    if (nResultado < 0) then
      nResultado := 0;

  finally
    Result := nResultado;
  end;
end;

{ TImpostoB }

function TImpostoB.CalculaImposto(nValor: Double): Double;
var
  nResultado: Double;
  ImpA: TImpostoA;
begin
  nResultado := 0;
  try
    if (nValor <= 0) then
      Exit;

    ImpA := TImpostoA.Create;

    nResultado := ImpA.CalculaImposto(nValor) - 15;

    if (nResultado < 0) then
      nResultado := 0;

  finally
    Result := nResultado;
    if Assigned(ImpA) then
      FreeAndNil(ImpA);
  end;
end;

{ TImpostoC }

function TImpostoC.CalculaImposto(nValor: Double): Double;
var
  nResultado: Double;
  ImpA: TImpostoA;
  ImpB: TImpostoB;
begin
  nResultado := 0;
  try
    if (nValor <= 0) then
      Exit;

    ImpA := TImpostoA.Create;
    ImpB := TImpostoB.Create;
    nResultado := ImpA.CalculaImposto(nValor) + ImpB.CalculaImposto(nValor);

    if (nResultado < 0) then
      nResultado := 0;

  finally
    Result := nResultado;
    if Assigned(ImpA) then
      FreeAndNil(ImpA);
    if Assigned(ImpB) then
      FreeAndNil(ImpB);
  end;
end;

end.
